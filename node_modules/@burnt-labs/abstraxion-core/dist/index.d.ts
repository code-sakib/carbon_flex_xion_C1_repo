import { SigningCosmWasmClient, SigningCosmWasmClientOptions, DeliverTxResponse, CosmWasmClient } from '@cosmjs/cosmwasm-stargate';
import { AccountData, OfflineSigner, EncodeObject } from '@cosmjs/proto-signing';
import { Account, StdFee, SignerData } from '@cosmjs/stargate';
import { TxRaw, SignDoc } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
import { HttpEndpoint, CometClient } from '@cosmjs/tendermint-rpc';
import { GenericAuthorization } from 'cosmjs-types/cosmos/authz/v1beta1/authz';
import { SendAuthorization } from 'cosmjs-types/cosmos/bank/v1beta1/authz';
import { Coin } from 'cosmjs-types/cosmos/base/v1beta1/coin';
import { StakeAuthorization } from 'cosmjs-types/cosmos/staking/v1beta1/authz';
import { TransferAuthorization } from 'cosmjs-types/ibc/applications/transfer/v1/authz';
import * as _cosmjs_amino from '@cosmjs/amino';
import { KdfConfiguration, Coin as Coin$1 } from '@cosmjs/amino';
import { EnglishMnemonic, HdPath } from '@cosmjs/crypto';

interface GranteeSignerOptions {
    readonly granterAddress: string;
    readonly granteeAddress: string;
    readonly treasuryAddress?: string;
}
declare class GranteeSignerClient extends SigningCosmWasmClient {
    protected readonly granterAddress: string;
    private readonly _granteeAddress;
    private readonly _signer;
    private readonly _gasPrice?;
    private readonly _treasury?;
    private readonly _defaultGasMultiplier;
    get granteeAddress(): string;
    getGranteeAccountData(): Promise<AccountData | undefined>;
    static connectWithSigner(endpoint: string | HttpEndpoint, signer: OfflineSigner, options: SigningCosmWasmClientOptions & GranteeSignerOptions): Promise<GranteeSignerClient>;
    static createWithSigner(cometClient: CometClient, signer: OfflineSigner, options: SigningCosmWasmClientOptions & GranteeSignerOptions): Promise<GranteeSignerClient>;
    protected constructor(cometClient: CometClient | undefined, signer: OfflineSigner, { granterAddress, granteeAddress, gasPrice, treasuryAddress, ...options }: SigningCosmWasmClientOptions & GranteeSignerOptions);
    getAccount(searchAddress: string): Promise<Account | null>;
    private transformForMsgExec;
    simulate(signerAddress: string, messages: readonly EncodeObject[], memo: string | undefined, feeGranter?: string): Promise<number>;
    signAndBroadcast(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee | "auto" | number, memo?: string): Promise<DeliverTxResponse>;
    sign(signerAddress: string, messages: readonly EncodeObject[], fee: StdFee, memo: string, explicitSignerData?: SignerData): Promise<TxRaw>;
}

declare enum AuthorizationTypes {
    Generic = "/cosmos.authz.v1beta1.GenericAuthorization",
    Send = "/cosmos.bank.v1beta1.SendAuthorization",
    IbcTransfer = "/ibc.applications.transfer.v1.TransferAuthorization",
    Stake = "/cosmos.staking.v1beta1.StakeAuthorization",
    ContractExecution = "/cosmwasm.wasm.v1.ContractExecutionAuthorization",
    Unsupported = "Unsupported"
}
declare enum ContractExecFilterTypes {
    AcceptedKeys = "/cosmwasm.wasm.v1.AcceptedMessageKeysFilter",
    AcceptedMessages = "/cosmwasm.wasm.v1.AcceptedMessagesFilter",
    AllowAll = "/cosmwasm.wasm.v1.AllowAllMessagesFilter"
}
declare enum ContractExecLimitTypes {
    MaxCalls = "/cosmwasm.wasm.v1.MaxCallsLimit",
    MaxFunds = "/cosmwasm.wasm.v1.MaxFundsLimit",
    CombinedLimit = "/cosmwasm.wasm.v1.CombinedLimit"
}

interface GrantsResponse {
    grants: Grant[];
    pagination: Pagination;
}
interface Grant {
    granter?: string;
    grantee?: string;
    authorization: any;
    expiration: string;
}
interface TreasuryGrantConfig {
    description: string;
    authorization: {
        type_url: string;
        value: string;
    };
    optional: boolean;
}
interface Authorization {
    "@type": string;
    grants: GrantAuthorization[];
}
interface GrantAuthorization {
    contract: string;
    limit: Limit;
    filter: Filter;
}
interface Limit {
    "@type": string;
    remaining?: string;
    calls_remaining?: string;
    amounts?: SpendLimit[];
}
interface Filter {
    "@type": string;
}
interface Pagination {
    next_key: null | string;
    total: string;
}
type SpendLimit = {
    denom: string;
    amount: string;
};
type ContractGrantDescription = string | {
    address: string;
    amounts: SpendLimit[];
};
interface AminoSignDoc {
    chain_id: string;
    account_number: string;
    sequence: string;
    fee: {
        amount: never[];
        gas: string;
    };
    msgs: {
        type: string;
        value: {
            signer: string;
            data: string;
        };
    }[];
    memo: string;
}
interface DecodedExecuteContracts {
    address: string;
    limitType?: ContractExecLimitTypes;
    maxCalls?: string;
    maxFunds?: Coin[];
    filterType?: ContractExecFilterTypes;
    messages?: Uint8Array[];
    keys?: string[];
}
interface HumanContractExecAuth {
    grants: DecodedExecuteContracts[];
}
interface DecodedReadableAuthorization {
    type: AuthorizationTypes;
    data: GenericAuthorization | SendAuthorization | TransferAuthorization | StakeAuthorization | HumanContractExecAuth | null;
}

interface DirectSecp256k1HdWalletOptions {
    /** The password to use when deriving a BIP39 seed from a mnemonic. */
    readonly bip39Password: string;
    /** The BIP-32/SLIP-10 derivation paths. Defaults to the Cosmos Hub/ATOM path `m/44'/118'/0'/0/0`. */
    readonly hdPaths: readonly HdPath[];
    /** The bech32 address prefix (human readable part). Defaults to "cosmos". */
    readonly prefix: string;
}
interface DirectSecp256k1HdWalletConstructorOptions extends Partial<DirectSecp256k1HdWalletOptions> {
    readonly seed: Uint8Array;
}
declare class SignArbSecp256k1HdWallet {
    /** Base secret */
    private readonly secret;
    /** BIP39 seed */
    private readonly seed;
    /** Derivation instructions */
    private readonly accounts;
    protected constructor(mnemonic: EnglishMnemonic, options: DirectSecp256k1HdWalletConstructorOptions);
    static fromMnemonic(mnemonic: string, options?: Partial<DirectSecp256k1HdWalletOptions>): Promise<SignArbSecp256k1HdWallet>;
    /**
     * Generates a new wallet with a BIP39 mnemonic of the given length.
     *
     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
     */
    static generate(length?: number, options?: {}): Promise<SignArbSecp256k1HdWallet>;
    /**
     * Restores a wallet from an encrypted serialization.
     *
     * @param password - The user provided password used to generate an encryption key via a KDF.
     *                 This is not normalized internally (see "Unicode normalization" to learn more).
     */
    static deserialize(serialization: string, password: string): Promise<SignArbSecp256k1HdWallet>;
    /**
     * Restores a wallet from an encrypted serialization.
     *
     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
     *
     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
     */
    static deserializeWithEncryptionKey(serialization: string, encryptionKey: Uint8Array): Promise<SignArbSecp256k1HdWallet>;
    private static deserializeTypeV1;
    private getKeyPair;
    executeKdf(password: string, configuration: KdfConfiguration): Promise<Uint8Array<ArrayBufferLike>>;
    /**
     * Generates an encrypted serialization of this wallet.
     *
     * @param password The user provided password used to generate an encryption key via a KDF.
     *                 This is not normalized internally (see "Unicode normalization" to learn more).
     */
    serialize(password: string): Promise<string>;
    /**
     * Generates an encrypted serialization of this wallet.
     *
     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
     *
     * The caller is responsible for ensuring the key was derived with the given KDF options. If this
     * is not the case, the wallet cannot be restored with the original password.
     */
    serializeWithEncryptionKey(encryptionKey: Uint8Array, kdfConfiguration: KdfConfiguration): Promise<string>;
    getAccounts(): Promise<readonly AccountData[]>;
    private getAccountsWithPrivkeys;
    signDirect(signerAddress: string, signDoc: SignDoc): Promise<{
        signed: SignDoc;
        signature: _cosmjs_amino.StdSignature;
    }>;
    signArb: (signerAddress: string, message: string | Uint8Array) => Promise<string>;
}

interface StorageStrategy {
    getItem(key: string): Promise<string | null>;
    setItem(key: string, value: string): Promise<void>;
    removeItem(key: string): Promise<void>;
}
interface RedirectStrategy {
    getCurrentUrl(): Promise<string>;
    redirect(url: string): Promise<void>;
    getUrlParameter(param: string): Promise<string | null>;
    onRedirectComplete?(callback: (params: {
        granter?: string | null;
    }) => void): Promise<void>;
    removeRedirectHandler?(): Promise<void>;
}

declare class AbstraxionAuth {
    private storageStrategy;
    private redirectStrategy;
    private rpcUrl?;
    private restUrl?;
    grantContracts?: ContractGrantDescription[];
    stake?: boolean;
    bank?: SpendLimit[];
    callbackUrl?: string;
    treasury?: string;
    private client?;
    private cosmwasmQueryClient?;
    abstractAccount?: SignArbSecp256k1HdWallet;
    private isLoginInProgress;
    isLoggedIn: boolean;
    authStateChangeSubscribers: ((isLoggedIn: boolean) => void)[];
    /**
     * Creates an instance of the AbstraxionAuth class.
     */
    constructor(storageStrategy: StorageStrategy, redirectStrategy: RedirectStrategy);
    /**
     * Updates AbstraxionAuth instance with user config
     *
     * @param {string} rpc - The RPC URL used for communication with the blockchain.
     * @param {string} [restUrl] - The REST URL used for additional communication.
     * @param {ContractGrantDescription[]} [grantContracts] - Contracts for granting permissions.
     * @param {boolean} [stake] - Indicates whether staking is enabled.
     * @param {SpendLimit[]} [bank] - The spend limits for the user.
     * @param {string} callbackUrl - preferred callback url to override default
     * @param {string} treasury - treasury contract instance address
     */
    configureAbstraxionInstance(rpc: string, restUrl?: string, grantContracts?: ContractGrantDescription[], stake?: boolean, bank?: SpendLimit[], callbackUrl?: string, treasury?: string): void;
    /**
     * Subscribes to changes in authentication state.
     * When the authentication state changes, the provided callback function is invoked
     * with the new authentication state (isLoggedIn).
     * Returns an unsubscribe function that can be called to remove the subscription.
     *
     * @param {function} callback - A function to be invoked when the authentication state changes.
     *                             Receives a single parameter, isLoggedIn, indicating whether the user is logged in.
     *                             The callback should accept a boolean parameter.
     * @returns {function} - A function that, when called, removes the subscription to authentication state changes.
     *                      This function should be invoked to clean up the subscription when no longer needed.
     */
    subscribeToAuthStateChange(callback: (isLoggedIn: boolean) => void): () => void;
    /**
     * Triggers a change in authentication state and notifies all subscribers.
     *
     * @param {boolean} isLoggedIn - The new authentication state, indicating whether the user is logged in.
     */
    private triggerAuthStateChange;
    /**
     * Get the account address of the granter from persisted state.
     *
     * @returns {string} The account address of the granter wallet (XION Meta Account).
     */
    getGranter(): Promise<string>;
    /**
     * Remove persisted instance of granter account.
     */
    private removeGranterAddress;
    /**
     * Set a persisted instance for granter account.
     *
     * @param {string} address - account address of the granter wallet (XION Meta Account).
     */
    private setGranter;
    /**
     * Get temp keypair from persisted state.
     */
    getLocalKeypair(): Promise<SignArbSecp256k1HdWallet | undefined>;
    /**
     * Generate a new temp keypair and store in persisted state.
     */
    generateAndStoreTempAccount(): Promise<SignArbSecp256k1HdWallet>;
    /**
     * Get keypair account address.
     */
    getKeypairAddress(): Promise<string>;
    /**
     * Get GranteeSignerClient for the temp keypair.
     */
    getSigner(): Promise<GranteeSignerClient>;
    /**
     * Get non-signing CosmWasmClient
     * @returns {Promise<CosmWasmClient>} A Promise that resolves to a CosmWasmClient
     * @throws {Error} If the rpcUrl is missing, or if there is a network issue.
     */
    getCosmWasmClient(): Promise<CosmWasmClient>;
    /**
     * Get dashboard url and redirect in order to issue claim with XION meta account for local keypair.
     */
    redirectToDashboard(): Promise<void>;
    /**
     * Configure URL and redirect page
     */
    private configureUrlAndRedirect;
    /**
     * Compares a GrantsResponse object to the legacy configuration stored in the instance.
     * Validates the presence and attributes of grants for each authorization type.
     *
     * @param {GrantsResponse} grantsResponse - The grants response object containing the chain grants.
     * @returns {boolean} - Returns `true` if the grants match the expected configuration; otherwise, `false`.
     */
    compareGrantsToLegacyConfig(grantsResponse: GrantsResponse): boolean;
    /**
     * Compares treasury grant configurations with the grants on-chain to ensure they match.
     *
     * @param {GrantsResponse} grantsResponse - The grants currently existing on-chain.
     * @returns {Promise<boolean>} - Returns a promise that resolves to `true` if all treasury grants match chain grants; otherwise, `false`.
     * @throws {Error} - Throws an error if the treasury contract is missing.
     */
    compareGrantsToTreasury(grantsResponse: GrantsResponse): Promise<boolean>;
    /**
     * Poll for grants issued to a grantee from a granter.
     *
     * @param {string} grantee - The address of the grantee.
     * @param {string | null} granter - The address of the granter, or null if not available.
     * @returns {Promise<boolean>} A Promise that resolves to true if grants are found, otherwise false.
     * @throws {Error} If the grantee or granter address is invalid, or if maximum retries are exceeded.
     */
    pollForGrants(grantee: string, granter: string | null): Promise<boolean>;
    /**
     * Wipe persisted state and instance variables.
     */
    logout(): Promise<void>;
    /**
     * Authenticates the user based on the presence of a local keypair and a granter address.
     * Also checks if the grant is still valid by verifying the expiration.
     * If valid, sets the abstract account and triggers authentication state change.
     * If expired, clears local state and prompts reauthorization.
     *
     * @returns {Promise<void>} - Resolves if authentication is successful or logs out the user otherwise.
     */
    authenticate(): Promise<void>;
    /**
     * Initiates the login process for the user.
     * Checks if a local keypair and granter address exist, either from URL parameters or this.storageStrategy.
     * If both exist, polls for grants and updates the authentication state if successful.
     * If not, generates a new keypair and redirects to the dashboard for grant issuance.
     *
     * @returns {Promise<void>} - A Promise that resolves once the login process is complete.
     * @throws {Error} - If the login process encounters an error.
     */
    login(): Promise<void>;
    /**
     * Initiates the flow to generate a new keypair and redirect to the dashboard for grant issuance.
     */
    private newKeypairFlow;
}

/**
 * Retrieves the type URLs for the treasury contract.
 *
 * @param {CosmWasmClient} client - The CosmWasm client to interact with the blockchain.
 * @param {string} treasuryAddress - The address of the treasury contract.
 * @returns {Promise<string[]>} - A promise that resolves to an array of type URLs.
 */
declare const getTreasuryContractTypeUrls: (client: CosmWasmClient, treasuryAddress: string) => Promise<string[]>;
/**
 * Retrieves the treasury grant configurations by type URL.
 *
 * @param {CosmWasmClient} client - The CosmWasm client to interact with the blockchain.
 * @param {string} treasuryAddress - The address of the treasury contract.
 * @param {string[]} typeUrls - An array of type URLs to query.
 * @returns {Promise<TreasuryGrantConfig[]>} - A promise that resolves to an array of TreasuryGrantConfig objects.
 */
declare const getTreasuryContractConfigsByTypeUrl: (client: CosmWasmClient, treasuryAddress: string, typeUrls: string[]) => Promise<TreasuryGrantConfig[]>;
/**
 * Fetch grants issued to a grantee from a granter using ABCI query.
 *
 * @param {string} grantee - The address of the grantee.
 * @param {string} granter - The address of the granter.
 * @param {string} [rpcUrl] - RPC URL to use for fetching grants.
 * @returns {Promise<GrantsResponse>} A Promise that resolves to the grants response.
 * @throws {Error} If the grantee or granter address is invalid, or if there's an error fetching grants.
 */
declare const fetchChainGrantsABCI: (grantee?: string, granter?: string, rpcUrl?: string) => Promise<GrantsResponse>;

/**
 * Decodes an authorization value based on its type.
 *
 * @param {string} typeUrl - The type URL of the authorization (e.g., `/cosmos.bank.v1beta1.SendAuthorization`).
 * @param {string | Uint8Array} value - The base64-encoded authorization value to decode, which can be a string or a Uint8Array.
 * @returns {DecodedReadableAuthorization} - Returns an object containing decoded authorization fields
 */
declare const decodeAuthorization: (typeUrl: string, value: string | Uint8Array) => DecodedReadableAuthorization;

/**
 * Generic function that validates if a chain limit is less than or equal to an expected limit.
 * This is used to validate that on-chain limits have not increased beyond what was authorized.
 *
 * @template T - Type with denom and amount properties
 * @param {T[] | undefined} expectedLimit - The expected limit from the decoded authorization
 * @param {T[] | undefined} chainLimit - The actual limit from the chain
 * @returns {boolean} - Returns true if the chain limit is less than or equal to the expected limit
 */
declare const isLimitValid: <T extends {
    denom: string;
    amount: string;
}>(expectedLimit: T[] | undefined, chainLimit: T[] | undefined) => boolean;
/**
 * Validates that decoded contract execution authorizations match the on-chain authorizations.
 * @param {DecodeAuthorizationResponse} treasuryAuth - The decoded authorization from treasury
 *        containing contract grants with their limits and filters
 * @param {DecodeAuthorizationResponse} chainAuth - The decoded on-chain authorization to validate against, containing
 *        grants with their respective limits and filters
 * @returns {boolean} Returns true if all contract execution authorizations match,
 *         false if any discrepancy is found
 */
declare const validateContractExecution: (treasuryAuth: DecodedReadableAuthorization, chainAuth: DecodedReadableAuthorization) => boolean;
/**
 * Compares treasury grant configurations with the grants on-chain to ensure they match.
 *
 * @param {DecodedReadableAuthorization[]} decodedChainConfigs - The decoded grants currently existing on-chain.
 * @param {DecodedReadableAuthorization[]} decodedTreasuryConfigs - The decoded treasury grant configurations to compare against.
 * @returns {boolean} - Returns `true` if all treasury grants match chain grants; otherwise, `false`.
 */
declare function compareChainGrantsToTreasuryGrants(decodedChainConfigs: DecodedReadableAuthorization[], decodedTreasuryConfigs: DecodedReadableAuthorization[]): boolean;
/**
 * Compares on-chain contract grants to ensure they match the specified grant contracts.
 *
 * @param {Grant[]} grants - The list of on-chain grants to compare.
 * @param {ContractGrantDescription[]} [grantContracts] - The optional list of contract grant descriptions to compare against.
 * @returns {boolean} - Returns `true` if all specified contract grants match; otherwise, `false`.
 */
declare const compareContractGrants: (grants: Grant[], grantContracts?: ContractGrantDescription[]) => boolean;
/**
 * Compares on-chain stake grants to ensure the expected stake types are granted.
 *
 * @param {Grant[]} grants - The list of on-chain grants to compare.
 * @param {boolean} [stake] - A flag indicating whether to check for stake grants.
 * @returns {boolean} - Returns `true` if the expected stake types are granted; otherwise, `false`.
 */
declare const compareStakeGrants: (grants: Grant[], stake?: boolean) => boolean;
/**
 * Compares on-chain bank grants to ensure the specified bank spend limits are granted.
 *
 * @param {Grant[]} grants - The list of on-chain grants to compare.
 * @param {SpendLimit[]} [bank] - The optional list of spend limits to check against.
 * @returns {boolean} - Returns `true` if all specified bank grants match; otherwise, `false`.
 */
declare const compareBankGrants: (grants: Grant[], bank?: SpendLimit[]) => boolean;

/**
 * Formats an array of coins into a string representation.
 *
 * @param {Coin[]} [coins=[]] - An array of Coin objects to format.
 * @returns {string} - A string representation of the coins (e.g. "1000uxion,1000ibc/123")
 */
declare const formatCoinArray: (coins?: Coin$1[]) => string;
/**
 * Parses a comma-separated coin string into a sorted Coin array.
 *
 * @param {string} input Comma-separated string of coins (e.g. "1000uxion,1000ibc/123")
 * @returns {Coin[]} sorted alphabetically by denom
 */
declare const parseCoinString: (input: string) => Coin$1[];

export { AbstraxionAuth, AminoSignDoc, Authorization, AuthorizationTypes, ContractExecFilterTypes, ContractExecLimitTypes, ContractGrantDescription, DecodedExecuteContracts, DecodedReadableAuthorization, Filter, Grant, GrantAuthorization, GranteeSignerClient, GrantsResponse, HumanContractExecAuth, Limit, Pagination, RedirectStrategy, SignArbSecp256k1HdWallet, SpendLimit, StorageStrategy, TreasuryGrantConfig, compareBankGrants, compareChainGrantsToTreasuryGrants, compareContractGrants, compareStakeGrants, decodeAuthorization, fetchChainGrantsABCI, formatCoinArray, getTreasuryContractConfigsByTypeUrl, getTreasuryContractTypeUrls, isLimitValid, parseCoinString, validateContractExecution };
