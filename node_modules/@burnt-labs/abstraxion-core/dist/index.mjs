import { isNonNullObject, assert } from '@cosmjs/utils';
import { accountFromAny } from '@cosmjs/stargate/build/accounts';
import { encodePubkey, makeSignBytes, decodePubkey } from '@cosmjs/proto-signing';
import { HttpClient, WebsocketClient, Comet38Client } from '@cosmjs/tendermint-rpc';
import { SigningCosmWasmClient, CosmWasmClient } from '@cosmjs/cosmwasm-stargate';
import { createProtobufRpcClient, calculateFee, QueryClient, GasPrice } from '@cosmjs/stargate';
import { AuthInfo, Fee, TxRaw } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
import { MsgExec } from 'cosmjs-types/cosmos/authz/v1beta1/tx';
import { Uint53 } from '@cosmjs/math';
import { makeCosmoshubPath, encodeSecp256k1Pubkey, rawSecp256k1PubkeyToRawAddress, encodeSecp256k1Signature, serializeSignDoc } from '@cosmjs/amino';
import { ServiceClientImpl, SimulateRequest } from 'cosmjs-types/cosmos/tx/v1beta1/service';
import { SignMode } from 'cosmjs-types/cosmos/tx/signing/v1beta1/signing';
import { fetchConfig } from '@burnt-labs/constants';
import { Buffer as Buffer$1 } from 'buffer';
import { EnglishMnemonic, Bip39, Random, stringToPath, Slip10, Slip10Curve, Secp256k1, isArgon2idOptions, Argon2id, pathToString, sha256, Sha256 } from '@cosmjs/crypto';
import { fromBase64, fromUtf8, toUtf8, toBase64, toBech32 } from '@cosmjs/encoding';
import { decrypt, executeKdf, cosmjsSalt, supportedAlgorithms, encrypt } from '@cosmjs/proto-signing/build/wallet';
import { QueryClientImpl } from 'cosmjs-types/cosmos/authz/v1beta1/query';
import { toByteArray } from 'base64-js';
import { GenericAuthorization } from 'cosmjs-types/cosmos/authz/v1beta1/authz';
import { StakeAuthorization } from 'cosmjs-types/cosmos/staking/v1beta1/authz';
import { SendAuthorization } from 'cosmjs-types/cosmos/bank/v1beta1/authz';
import { TransferAuthorization } from 'cosmjs-types/ibc/applications/transfer/v1/authz';
import { ContractExecutionAuthorization, CombinedLimit, MaxFundsLimit, MaxCallsLimit, AcceptedMessagesFilter, AcceptedMessageKeysFilter } from 'cosmjs-types/cosmwasm/wasm/v1/authz';

// src/utils/accountParser.ts

// src/types/abstractaccount/v1/account.ts
var AbstractAccount;
((AbstractAccount2) => {
  function fromBinary(binary) {
    const decoder = new TextDecoder();
    let data;
    try {
      data = JSON.parse(decoder.decode(binary));
    } catch (e) {
      data = {};
    }
    return {
      address: data.address || "",
      accountNumber: BigInt(data.account_number || 0),
      sequence: BigInt(data.sequence || 0)
    };
  }
  AbstractAccount2.fromBinary = fromBinary;
})(AbstractAccount || (AbstractAccount = {}));

// src/utils/accountParser.ts
function uint64FromProto(input) {
  return typeof input === "bigint" ? Number(input) : input;
}
function accountFromBaseAccount(input) {
  const { address, pubKey, accountNumber, sequence } = input;
  let pubkey = null;
  if (pubKey) {
    pubkey = decodePubkey(pubKey);
  }
  return {
    address,
    pubkey,
    accountNumber: uint64FromProto(accountNumber),
    sequence: uint64FromProto(sequence)
  };
}
function customAccountFromAny(input) {
  const { typeUrl, value } = input;
  switch (typeUrl) {
    case "/abstractaccount.v1.AbstractAccount": {
      const abstractAccount = AbstractAccount.fromBinary(value);
      assert(abstractAccount);
      return accountFromBaseAccount(abstractAccount);
    }
    default:
      return accountFromAny(input);
  }
}
var getRpcClient = async (endpoint) => {
  const useHttp = typeof endpoint === "string" ? endpoint.startsWith("http://") || endpoint.startsWith("https://") : endpoint.url.startsWith("http://") || endpoint.url.startsWith("https://");
  const rpcClient = useHttp ? new HttpClient(endpoint) : new WebsocketClient(
    typeof endpoint === "string" ? endpoint : endpoint.url
  );
  return Comet38Client.create(rpcClient);
};

// src/utils/index.ts
function makeADR36AminoSignDoc(signer, message) {
  return {
    chain_id: "",
    account_number: "0",
    sequence: "0",
    fee: {
      amount: [],
      gas: "0"
    },
    msgs: [
      {
        type: "sign/MsgSignData",
        value: {
          signer,
          data: typeof message === "string" ? Buffer.from(message).toString("base64") : Buffer.from(message).toString("base64")
        }
      }
    ],
    memo: ""
  };
}
var GranteeSignerClient = class extends SigningCosmWasmClient {
  granterAddress;
  _granteeAddress;
  _signer;
  _gasPrice;
  _treasury;
  _defaultGasMultiplier = 1.4;
  // cosmjs 0.32.4 default
  get granteeAddress() {
    return this._granteeAddress;
  }
  async getGranteeAccountData() {
    return this._signer.getAccounts().then((accounts) => {
      for (const account of accounts) {
        if (account.address === this._granteeAddress) {
          return account;
        }
      }
    });
  }
  static async connectWithSigner(endpoint, signer, options) {
    const tmClient = await getRpcClient(endpoint);
    return GranteeSignerClient.createWithSigner(tmClient, signer, options);
  }
  static async createWithSigner(cometClient, signer, options) {
    return new GranteeSignerClient(cometClient, signer, options);
  }
  constructor(cometClient, signer, {
    granterAddress,
    granteeAddress,
    gasPrice,
    treasuryAddress,
    ...options
  }) {
    super(cometClient, signer, { ...options, gasPrice });
    if (granterAddress === void 0) {
      throw new Error("granterAddress is required");
    }
    this.granterAddress = granterAddress;
    if (granteeAddress === void 0) {
      throw new Error("granteeAddress is required");
    }
    this._granteeAddress = granteeAddress;
    this._gasPrice = gasPrice;
    this._treasury = treasuryAddress;
    this._signer = signer;
  }
  async getAccount(searchAddress) {
    const account = await this.forceGetQueryClient().auth.account(searchAddress);
    if (!account) {
      return null;
    }
    return customAccountFromAny(account);
  }
  transformForMsgExec(signerAddress, messages) {
    if (signerAddress === this.granterAddress) {
      signerAddress = this.granteeAddress;
      messages = [
        {
          typeUrl: "/cosmos.authz.v1beta1.MsgExec",
          value: MsgExec.fromPartial({
            grantee: this.granteeAddress,
            msgs: messages.map((msg) => this.registry.encodeAsAny(msg))
          })
        }
      ];
    }
    return { signerAddress, messages };
  }
  async simulate(signerAddress, messages, memo, feeGranter) {
    const {
      signerAddress: transformedSignerAddress,
      messages: transformedMessages
    } = this.transformForMsgExec(signerAddress, messages);
    const { sequence } = await this.getSequence(transformedSignerAddress);
    const accountFromSigner = (await this._signer.getAccounts()).find(
      (account) => account.address === transformedSignerAddress
    );
    if (!accountFromSigner) {
      throw new Error("No account found.");
    }
    const pubkey = encodeSecp256k1Pubkey(accountFromSigner.pubkey);
    const queryClient = this.getQueryClient();
    if (!queryClient) {
      throw new Error("Couldn't get query client");
    }
    const rpc = createProtobufRpcClient(queryClient);
    const queryService = new ServiceClientImpl(rpc);
    const authInfo = AuthInfo.fromPartial({
      fee: Fee.fromPartial({ granter: feeGranter }),
      signerInfos: [
        {
          publicKey: encodePubkey(pubkey),
          modeInfo: {
            single: {
              mode: SignMode.SIGN_MODE_DIRECT
            }
          },
          sequence: BigInt(sequence)
        }
      ]
    });
    const authInfoBytes = AuthInfo.encode(authInfo).finish();
    const txBodyEncodeObject = {
      typeUrl: "/cosmos.tx.v1beta1.TxBody",
      value: {
        messages: transformedMessages,
        memo
      }
    };
    const bodyBytes = this.registry.encode(txBodyEncodeObject);
    const tx = TxRaw.fromPartial({
      bodyBytes,
      authInfoBytes,
      signatures: [new Uint8Array([10])]
    });
    const request = SimulateRequest.fromPartial({
      txBytes: TxRaw.encode(tx).finish()
    });
    const { gasInfo } = await queryService.Simulate(request);
    if (!gasInfo) {
      throw new Error("No gas info returned");
    }
    return Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
  }
  async signAndBroadcast(signerAddress, messages, fee, memo = "") {
    const {
      signerAddress: transformedSignerAddress,
      messages: transformedMessages
    } = this.transformForMsgExec(signerAddress, messages);
    let usedFee;
    const granter = this._treasury ? this._treasury : this.granterAddress;
    if (fee == "auto" || typeof fee === "number") {
      if (!this._gasPrice) {
        throw new Error(
          "Gas price must be set in the client options when auto gas is used"
        );
      }
      const gasEstimation = await this.simulate(
        transformedSignerAddress,
        transformedMessages,
        memo,
        granter
      );
      const multiplier = typeof fee == "number" ? fee : this._defaultGasMultiplier;
      const calculatedFee = calculateFee(
        Math.round(gasEstimation * multiplier),
        this._gasPrice
      );
      usedFee = {
        ...calculatedFee,
        granter
      };
    } else {
      usedFee = { ...fee, granter };
    }
    const txRaw = await this.sign(
      transformedSignerAddress,
      transformedMessages,
      usedFee,
      memo,
      void 0
    );
    const txBytes = TxRaw.encode(txRaw).finish();
    return this.broadcastTx(
      txBytes,
      this.broadcastTimeoutMs,
      this.broadcastPollIntervalMs
    );
  }
  async sign(signerAddress, messages, fee, memo, explicitSignerData) {
    if (signerAddress === this.granterAddress) {
      signerAddress = this.granteeAddress;
      messages = [
        {
          typeUrl: "/cosmos.authz.v1beta1.MsgExec",
          value: MsgExec.fromPartial({
            grantee: signerAddress,
            msgs: messages.map((msg) => this.registry.encodeAsAny(msg))
          })
        }
      ];
    }
    return super.sign(signerAddress, messages, fee, memo, explicitSignerData);
  }
};
var serializationTypeV1 = "directsecp256k1hdwallet-v1";
var basicPasswordHashingOptions = {
  algorithm: "argon2id",
  params: {
    outputLength: 32,
    opsLimit: 24,
    memLimitKib: 12 * 1024
  }
};
function isDerivationJson(thing) {
  if (!isNonNullObject(thing))
    return false;
  if (typeof thing.hdPath !== "string")
    return false;
  if (typeof thing.prefix !== "string")
    return false;
  return true;
}
var defaultOptions = {
  bip39Password: "",
  hdPaths: [makeCosmoshubPath(0)],
  prefix: "cosmos"
};
var SignArbSecp256k1HdWallet = class {
  /** Base secret */
  secret;
  /** BIP39 seed */
  seed;
  /** Derivation instructions */
  accounts;
  constructor(mnemonic, options) {
    const prefix = options.prefix ?? defaultOptions.prefix;
    const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
    this.secret = mnemonic;
    this.seed = options.seed;
    this.accounts = hdPaths.map((hdPath) => ({
      hdPath,
      prefix
    }));
  }
  static async fromMnemonic(mnemonic, options = {}) {
    const mnemonicChecked = new EnglishMnemonic(mnemonic);
    const seed = await Bip39.mnemonicToSeed(
      mnemonicChecked,
      options.bip39Password
    );
    return new SignArbSecp256k1HdWallet(mnemonicChecked, {
      ...options,
      seed
    });
  }
  /**
   * Generates a new wallet with a BIP39 mnemonic of the given length.
   *
   * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
   */
  static async generate(length = 12, options = {}) {
    const entropyLength = 4 * Math.floor(11 * length / 33);
    const entropy = Random.getBytes(entropyLength);
    const mnemonic = Bip39.encode(entropy);
    return this.fromMnemonic(mnemonic.toString(), options);
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * @param password - The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  static async deserialize(serialization, password) {
    const root = JSON.parse(serialization);
    if (!isNonNullObject(root))
      throw new Error("Root document is not an object.");
    if (root.type === serializationTypeV1) {
      return this.deserializeTypeV1(serialization, password);
    }
    throw new Error("Unsupported serialization type");
  }
  /**
   * Restores a wallet from an encrypted serialization.
   *
   * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
   * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
   * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
   */
  static async deserializeWithEncryptionKey(serialization, encryptionKey) {
    const root = JSON.parse(serialization);
    if (!isNonNullObject(root))
      throw new Error("Root document is not an object.");
    const untypedRoot = root;
    switch (untypedRoot.type) {
      case serializationTypeV1: {
        const decryptedBytes = await decrypt(
          fromBase64(untypedRoot.data),
          encryptionKey,
          untypedRoot.encryption
        );
        const decryptedDocument = JSON.parse(fromUtf8(decryptedBytes));
        const { mnemonic, accounts } = decryptedDocument;
        assert(typeof mnemonic.data === "string");
        if (!Array.isArray(accounts))
          throw new Error("Property 'accounts' is not an array");
        if (!accounts.every((account) => isDerivationJson(account))) {
          throw new Error("Account is not in the correct format.");
        }
        const firstPrefix = accounts[0].prefix;
        if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
          throw new Error("Accounts do not all have the same prefix");
        }
        const hdPaths = accounts.map(
          ({ hdPath }) => stringToPath(hdPath)
        );
        return this.fromMnemonic(mnemonic.data, {
          hdPaths,
          prefix: firstPrefix
        });
      }
      default:
        throw new Error("Unsupported serialization type");
    }
  }
  static async deserializeTypeV1(serialization, password) {
    const root = JSON.parse(serialization);
    if (!isNonNullObject(root))
      throw new Error("Root document is not an object.");
    const encryptionKey = await executeKdf(password, root.kdf);
    return this.deserializeWithEncryptionKey(serialization, encryptionKey);
  }
  async getKeyPair(hdPath) {
    const { privkey } = Slip10.derivePath(
      Slip10Curve.Secp256k1,
      this.seed,
      hdPath
    );
    const { pubkey } = await Secp256k1.makeKeypair(privkey);
    return {
      privkey,
      pubkey: Secp256k1.compressPubkey(pubkey)
    };
  }
  async executeKdf(password, configuration) {
    switch (configuration.algorithm) {
      case "argon2id": {
        const options = configuration.params;
        if (!isArgon2idOptions(options))
          throw new Error("Invalid format of argon2id params");
        return Argon2id.execute(password, cosmjsSalt, options);
      }
      default:
        throw new Error("Unsupported KDF algorithm");
    }
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * @param password The user provided password used to generate an encryption key via a KDF.
   *                 This is not normalized internally (see "Unicode normalization" to learn more).
   */
  async serialize(password) {
    const kdfConfiguration = basicPasswordHashingOptions;
    const encryptionKey = await this.executeKdf(password, kdfConfiguration);
    return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
  }
  /**
   * Generates an encrypted serialization of this wallet.
   *
   * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
   * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
   *
   * The caller is responsible for ensuring the key was derived with the given KDF options. If this
   * is not the case, the wallet cannot be restored with the original password.
   */
  async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
    const dataToEncrypt = {
      mnemonic: this.secret,
      accounts: this.accounts.map(({ hdPath, prefix }) => ({
        hdPath: pathToString(hdPath),
        prefix
      }))
    };
    const dataToEncryptRaw = toUtf8(JSON.stringify(dataToEncrypt));
    const encryptionConfiguration = {
      algorithm: supportedAlgorithms.xchacha20poly1305Ietf
    };
    const encryptedData = await encrypt(
      dataToEncryptRaw,
      encryptionKey,
      encryptionConfiguration
    );
    const out = {
      type: serializationTypeV1,
      kdf: kdfConfiguration,
      encryption: encryptionConfiguration,
      data: toBase64(encryptedData)
    };
    return JSON.stringify(out);
  }
  async getAccounts() {
    const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
    return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
      algo,
      pubkey,
      address
    }));
  }
  async getAccountsWithPrivkeys() {
    return Promise.all(
      this.accounts.map(async ({ hdPath, prefix }) => {
        const { privkey, pubkey } = await this.getKeyPair(hdPath);
        const address = toBech32(
          prefix,
          rawSecp256k1PubkeyToRawAddress(pubkey)
        );
        return {
          algo: "secp256k1",
          privkey,
          pubkey,
          address
        };
      })
    );
  }
  async signDirect(signerAddress, signDoc) {
    const accounts = await this.getAccountsWithPrivkeys();
    const account = accounts.find(({ address }) => address === signerAddress);
    if (account === void 0) {
      throw new Error(`Address ${signerAddress} not found in wallet`);
    }
    const { privkey, pubkey } = account;
    const signBytes = makeSignBytes(signDoc);
    const hashedMessage = sha256(signBytes);
    const signature = await Secp256k1.createSignature(hashedMessage, privkey);
    const signatureBytes = new Uint8Array([
      ...signature.r(32),
      ...signature.s(32)
    ]);
    const stdSignature = encodeSecp256k1Signature(pubkey, signatureBytes);
    return {
      signed: signDoc,
      signature: stdSignature
    };
  }
  signArb = async (signerAddress, message) => {
    const accounts = await this.getAccountsWithPrivkeys();
    const account = accounts.find(({ address }) => address === signerAddress);
    if (account === void 0) {
      throw new Error(`Address ${signerAddress} not found in wallet`);
    }
    const { privkey } = account;
    const signDoc = makeADR36AminoSignDoc(signerAddress, message);
    const serializedSignDoc = serializeSignDoc(signDoc);
    const digest = new Sha256(serializedSignDoc).digest();
    const signature = await Secp256k1.createSignature(digest, privkey);
    return Buffer$1.from(
      new Uint8Array([...signature.r(32), ...signature.s(32)])
    ).toString("base64");
  };
};
var getTreasuryContractTypeUrls = async (client, treasuryAddress) => {
  const queryTreasuryContractMsg = { grant_config_type_urls: {} };
  return await client.queryContractSmart(
    treasuryAddress,
    queryTreasuryContractMsg
  );
};
var getTreasuryContractConfigsByTypeUrl = async (client, treasuryAddress, typeUrls) => {
  const treasuryGrantConfigs = [];
  for (const typeUrl of typeUrls) {
    const queryByMsg = {
      grant_config_by_type_url: { msg_type_url: typeUrl }
    };
    const grantConfigResponse = await client.queryContractSmart(treasuryAddress, queryByMsg);
    treasuryGrantConfigs.push(grantConfigResponse);
  }
  return treasuryGrantConfigs;
};
var fetchChainGrantsABCI = async (grantee, granter, rpcUrl) => {
  if (!grantee) {
    throw new Error("Grantee address is required");
  }
  if (!granter) {
    throw new Error("Granter address is required");
  }
  if (!rpcUrl) {
    throw new Error("RPC URL is required");
  }
  try {
    const rpcClient = await getRpcClient(rpcUrl);
    const queryClient = new QueryClient(rpcClient);
    const protobufRpcClient = createProtobufRpcClient(queryClient);
    const authzClient = new QueryClientImpl(protobufRpcClient);
    const response = await authzClient.Grants({
      grantee,
      granter,
      msgTypeUrl: ""
      // Empty string to get all grants
    });
    const grantsResponse = {
      grants: response.grants.map((grant) => ({
        granter,
        grantee,
        authorization: grant.authorization,
        expiration: grant.expiration ? new Date(Number(grant.expiration.seconds) * 1e3).toISOString() : ""
      })),
      pagination: {
        next_key: response.pagination?.nextKey?.toString() || null,
        total: response.pagination?.total.toString() || "0"
      }
    };
    return grantsResponse;
  } catch (error) {
    console.error("Error fetching grants:", error);
    throw error;
  } finally {
  }
};

// src/utils/grant/constants.ts
var AuthorizationTypes = /* @__PURE__ */ ((AuthorizationTypes2) => {
  AuthorizationTypes2["Generic"] = "/cosmos.authz.v1beta1.GenericAuthorization";
  AuthorizationTypes2["Send"] = "/cosmos.bank.v1beta1.SendAuthorization";
  AuthorizationTypes2["IbcTransfer"] = "/ibc.applications.transfer.v1.TransferAuthorization";
  AuthorizationTypes2["Stake"] = "/cosmos.staking.v1beta1.StakeAuthorization";
  AuthorizationTypes2["ContractExecution"] = "/cosmwasm.wasm.v1.ContractExecutionAuthorization";
  AuthorizationTypes2["Unsupported"] = "Unsupported";
  return AuthorizationTypes2;
})(AuthorizationTypes || {});
var ContractExecFilterTypes = /* @__PURE__ */ ((ContractExecFilterTypes2) => {
  ContractExecFilterTypes2["AcceptedKeys"] = "/cosmwasm.wasm.v1.AcceptedMessageKeysFilter";
  ContractExecFilterTypes2["AcceptedMessages"] = "/cosmwasm.wasm.v1.AcceptedMessagesFilter";
  ContractExecFilterTypes2["AllowAll"] = "/cosmwasm.wasm.v1.AllowAllMessagesFilter";
  return ContractExecFilterTypes2;
})(ContractExecFilterTypes || {});
var ContractExecLimitTypes = /* @__PURE__ */ ((ContractExecLimitTypes2) => {
  ContractExecLimitTypes2["MaxCalls"] = "/cosmwasm.wasm.v1.MaxCallsLimit";
  ContractExecLimitTypes2["MaxFunds"] = "/cosmwasm.wasm.v1.MaxFundsLimit";
  ContractExecLimitTypes2["CombinedLimit"] = "/cosmwasm.wasm.v1.CombinedLimit";
  return ContractExecLimitTypes2;
})(ContractExecLimitTypes || {});

// src/utils/grant/decoding.ts
var decodeAuthorization = (typeUrl, value) => {
  const processedAuthorizationValue = typeof value === "string" ? toByteArray(value) : value;
  switch (typeUrl) {
    case "/cosmos.authz.v1beta1.GenericAuthorization" /* Generic */:
      return {
        type: "/cosmos.authz.v1beta1.GenericAuthorization" /* Generic */,
        data: GenericAuthorization.decode(processedAuthorizationValue)
      };
    case "/cosmos.bank.v1beta1.SendAuthorization" /* Send */:
      return {
        type: "/cosmos.bank.v1beta1.SendAuthorization" /* Send */,
        data: SendAuthorization.decode(processedAuthorizationValue)
      };
    case "/ibc.applications.transfer.v1.TransferAuthorization" /* IbcTransfer */:
      return {
        type: "/ibc.applications.transfer.v1.TransferAuthorization" /* IbcTransfer */,
        data: TransferAuthorization.decode(processedAuthorizationValue)
      };
    case "/cosmos.staking.v1beta1.StakeAuthorization" /* Stake */:
      return {
        type: "/cosmos.staking.v1beta1.StakeAuthorization" /* Stake */,
        data: StakeAuthorization.decode(processedAuthorizationValue)
      };
    case "/cosmwasm.wasm.v1.ContractExecutionAuthorization" /* ContractExecution */: {
      const authorization = ContractExecutionAuthorization.decode(
        processedAuthorizationValue
      );
      let limitType;
      let maxCalls;
      let maxFunds;
      let filterType;
      let messages;
      let keys;
      const grants = authorization.grants.map((grant) => {
        if (grant.limit) {
          switch (grant.limit.typeUrl) {
            case "/cosmwasm.wasm.v1.MaxCallsLimit" /* MaxCalls */:
              limitType = "/cosmwasm.wasm.v1.MaxCallsLimit" /* MaxCalls */;
              maxCalls = MaxCallsLimit.decode(
                grant.limit.value
              ).remaining.toString();
              break;
            case "/cosmwasm.wasm.v1.MaxFundsLimit" /* MaxFunds */:
              limitType = "/cosmwasm.wasm.v1.MaxFundsLimit" /* MaxFunds */;
              maxFunds = MaxFundsLimit.decode(grant.limit.value).amounts;
              break;
            case "/cosmwasm.wasm.v1.CombinedLimit" /* CombinedLimit */: {
              const combined = CombinedLimit.decode(grant.limit.value);
              limitType = "/cosmwasm.wasm.v1.CombinedLimit" /* CombinedLimit */;
              maxCalls = combined.callsRemaining.toString();
              maxFunds = combined.amounts;
              break;
            }
          }
        }
        if (grant.filter) {
          switch (grant.filter.typeUrl) {
            case "/cosmwasm.wasm.v1.AcceptedMessageKeysFilter" /* AcceptedKeys */:
              filterType = "/cosmwasm.wasm.v1.AcceptedMessageKeysFilter" /* AcceptedKeys */;
              keys = AcceptedMessageKeysFilter.decode(grant.filter.value).keys;
              break;
            case "/cosmwasm.wasm.v1.AcceptedMessagesFilter" /* AcceptedMessages */:
              filterType = "/cosmwasm.wasm.v1.AcceptedMessagesFilter" /* AcceptedMessages */;
              messages = AcceptedMessagesFilter.decode(
                grant.filter.value
              ).messages;
              break;
            case "/cosmwasm.wasm.v1.AllowAllMessagesFilter" /* AllowAll */:
              filterType = "/cosmwasm.wasm.v1.AllowAllMessagesFilter" /* AllowAll */;
              break;
          }
        }
        return {
          address: grant.contract,
          limitType,
          maxCalls,
          maxFunds,
          filterType,
          messages,
          keys
        };
      });
      return { type: "/cosmwasm.wasm.v1.ContractExecutionAuthorization" /* ContractExecution */, data: { grants } };
    }
    default:
      return { type: "Unsupported" /* Unsupported */, data: null };
  }
};

// src/utils/grant/compare.ts
var isLimitValid = (expectedLimit, chainLimit) => {
  if (!expectedLimit || !chainLimit)
    return false;
  const expectedLimits = /* @__PURE__ */ new Map();
  for (const item of expectedLimit) {
    expectedLimits.set(item.denom, BigInt(item.amount));
  }
  for (const item of chainLimit) {
    const expectedAmount = expectedLimits.get(item.denom);
    if (expectedAmount === void 0)
      return false;
    if (BigInt(item.amount) > expectedAmount)
      return false;
  }
  return true;
};
var validateContractExecution = (treasuryAuth, chainAuth) => {
  const treasuryGrants = treasuryAuth && treasuryAuth.data && treasuryAuth.data.grants ? treasuryAuth.data.grants : [];
  const chainGrants = chainAuth && chainAuth.data && chainAuth.data.grants ? chainAuth.data.grants : [];
  return treasuryGrants.every((treasuryGrant) => {
    const matchingChainGrants = chainGrants.filter((chainGrant) => {
      if (chainGrant.address !== treasuryGrant.address) {
        return false;
      }
      if (treasuryGrant.filterType) {
        if (!chainGrant.filterType) {
          return false;
        }
        if (chainGrant.filterType !== treasuryGrant.filterType) {
          return false;
        }
        const decodedTreasuryKeys = treasuryGrant.keys || [];
        const decodedChainKeys = chainGrant.keys || [];
        if (decodedTreasuryKeys.length !== decodedChainKeys.length) {
          return false;
        }
        if (!decodedTreasuryKeys.every(
          (key, index) => key === decodedChainKeys[index]
        )) {
          return false;
        }
        const decodedTreasuryMessages = treasuryGrant.messages || [];
        const decodedChainMessages = chainGrant.messages || [];
        if (decodedTreasuryMessages.length !== decodedChainMessages.length) {
          return false;
        }
        const messagesMatch = decodedTreasuryMessages.every((msg, index) => {
          const chainMsg = decodedChainMessages[index];
          if (msg.length !== chainMsg.length) {
            return false;
          }
          for (let i = 0; i < msg.length; i++) {
            if (msg[i] !== chainMsg[i]) {
              return false;
            }
          }
          return true;
        });
        if (!messagesMatch) {
          return false;
        }
      } else if (chainGrant.filterType) {
        return false;
      }
      return true;
    });
    if (matchingChainGrants.length === 0) {
      return false;
    }
    const limitMatches = matchingChainGrants.some((matchingChainGrant) => {
      switch (treasuryGrant.limitType) {
        case "/cosmwasm.wasm.v1.MaxCallsLimit" /* MaxCalls */:
          return matchingChainGrant.limitType === "/cosmwasm.wasm.v1.MaxCallsLimit" /* MaxCalls */ && Number(matchingChainGrant.maxCalls) <= Number(treasuryGrant.maxCalls);
        case "/cosmwasm.wasm.v1.MaxFundsLimit" /* MaxFunds */:
          return matchingChainGrant.limitType === "/cosmwasm.wasm.v1.MaxFundsLimit" /* MaxFunds */ && isLimitValid(treasuryGrant.maxFunds, matchingChainGrant.maxFunds);
        case "/cosmwasm.wasm.v1.CombinedLimit" /* CombinedLimit */:
          return matchingChainGrant.limitType === "/cosmwasm.wasm.v1.CombinedLimit" /* CombinedLimit */ && Number(matchingChainGrant?.maxCalls) <= Number(treasuryGrant?.maxCalls) && isLimitValid(treasuryGrant?.maxFunds, matchingChainGrant?.maxFunds);
        default:
          return false;
      }
    });
    return limitMatches;
  });
};
function compareChainGrantsToTreasuryGrants(decodedChainConfigs, decodedTreasuryConfigs) {
  return decodedTreasuryConfigs.every((treasuryConfig) => {
    return decodedChainConfigs.find((chainConfig) => {
      const chainAuthType = chainConfig.type;
      const isTypeMatch = chainAuthType === treasuryConfig.type;
      if (!isTypeMatch)
        return false;
      if (chainAuthType === "/cosmos.authz.v1beta1.GenericAuthorization" /* Generic */) {
        return chainConfig.data.msg === treasuryConfig.data?.msg;
      }
      if (chainAuthType === "/cosmos.bank.v1beta1.SendAuthorization" /* Send */) {
        return isLimitValid(
          treasuryConfig.data.spendLimit,
          chainConfig.data.spendLimit
        ) && JSON.stringify(
          treasuryConfig.data.allowList
        ) === JSON.stringify(chainConfig.data.allowList);
      }
      if (chainAuthType === "/cosmos.staking.v1beta1.StakeAuthorization" /* Stake */) {
        const treasuryStakeAuth = treasuryConfig.data;
        const grantStakeAuth = chainConfig.data;
        return treasuryStakeAuth.authorizationType === grantStakeAuth.authorizationType && treasuryStakeAuth.maxTokens === grantStakeAuth.maxTokens && JSON.stringify(treasuryStakeAuth.allowList) === JSON.stringify(grantStakeAuth.allowList) && JSON.stringify(treasuryStakeAuth.denyList) === JSON.stringify(grantStakeAuth.denyList);
      }
      if (chainAuthType === "/cosmwasm.wasm.v1.ContractExecutionAuthorization" /* ContractExecution */) {
        return validateContractExecution(treasuryConfig, chainConfig);
      }
      return false;
    });
  });
}
var compareContractGrants = (grants, grantContracts) => {
  if (!grantContracts) {
    return true;
  }
  const contractGrants = grants.filter(
    (grant) => grant.authorization["@type"] === "/cosmwasm.wasm.v1.ContractExecutionAuthorization"
  );
  return grantContracts.every((contract) => {
    const address = typeof contract === "string" ? contract : contract.address;
    const amounts = typeof contract === "object" ? contract.amounts : [];
    const matchingGrants = contractGrants.filter(
      (grant) => grant.authorization.grants.some(
        (grant2) => grant2.contract === address
      )
    );
    if (!matchingGrants.length)
      return false;
    return amounts.length ? matchingGrants.some(
      (grant) => grant.authorization.grants.some(
        (authGrant) => authGrant.limit.amounts && isLimitValid(amounts, authGrant.limit.amounts)
      )
    ) : true;
  });
};
var compareStakeGrants = (grants, stake) => {
  if (!stake) {
    return true;
  }
  const stakeGrants = grants.filter(
    (grant) => [
      "/cosmos.staking.v1beta1.StakeAuthorization",
      "/cosmos.authz.v1beta1.GenericAuthorization"
    ].includes(grant.authorization["@type"])
  );
  const expectedStakeTypes = [
    "AUTHORIZATION_TYPE_DELEGATE",
    "AUTHORIZATION_TYPE_UNDELEGATE",
    "AUTHORIZATION_TYPE_REDELEGATE",
    "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
    "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation"
  ];
  const stakeTypesGranted = stakeGrants.map((grant) => {
    if (grant.authorization["@type"] === "/cosmos.staking.v1beta1.StakeAuthorization") {
      return grant.authorization.authorization_type;
    } else if (grant.authorization["@type"] === "/cosmos.authz.v1beta1.GenericAuthorization") {
      return grant.authorization.msg;
    }
  });
  return expectedStakeTypes.every((type) => stakeTypesGranted.includes(type));
};
var compareBankGrants = (grants, bank) => {
  if (!bank) {
    return true;
  }
  const bankGrants = grants.filter(
    (grant) => grant.authorization["@type"] === "/cosmos.bank.v1beta1.SendAuthorization"
  );
  return bank?.every(
    (bankEntry) => bankGrants.some(
      (grant) => isLimitValid([bankEntry], grant.authorization.spend_limit)
    )
  );
};

// src/utils/grant/utils.ts
var formatCoinArray = (coins = []) => {
  return coins.map((coin) => `${coin.amount}${coin.denom}`).join(", ");
};
var parseCoinString = (input) => {
  return input.split(",").map((coinStr) => coinStr.trim()).map((coinStr) => {
    const match = coinStr.match(/^(\d+)([a-zA-Z0-9\/]+)$/);
    if (!match)
      return null;
    const [, amount, denom] = match;
    return { amount, denom };
  }).filter((coin) => coin !== null).sort((a, b) => a.denom.localeCompare(b.denom));
};

// src/AbstraxionAuth.ts
var AbstraxionAuth = class {
  /**
   * Creates an instance of the AbstraxionAuth class.
   */
  constructor(storageStrategy, redirectStrategy) {
    this.storageStrategy = storageStrategy;
    this.redirectStrategy = redirectStrategy;
    if (this.redirectStrategy.onRedirectComplete) {
      this.redirectStrategy.onRedirectComplete(async (params) => {
        if (params.granter) {
          await this.setGranter(params.granter);
          await this.login();
        }
      });
    }
  }
  // Config
  rpcUrl;
  restUrl;
  grantContracts;
  stake;
  bank;
  callbackUrl;
  treasury;
  // Signer
  client;
  cosmwasmQueryClient;
  // Accounts
  abstractAccount;
  // State
  isLoginInProgress = false;
  isLoggedIn = false;
  authStateChangeSubscribers = [];
  /**
   * Updates AbstraxionAuth instance with user config
   *
   * @param {string} rpc - The RPC URL used for communication with the blockchain.
   * @param {string} [restUrl] - The REST URL used for additional communication.
   * @param {ContractGrantDescription[]} [grantContracts] - Contracts for granting permissions.
   * @param {boolean} [stake] - Indicates whether staking is enabled.
   * @param {SpendLimit[]} [bank] - The spend limits for the user.
   * @param {string} callbackUrl - preferred callback url to override default
   * @param {string} treasury - treasury contract instance address
   */
  configureAbstraxionInstance(rpc, restUrl, grantContracts, stake, bank, callbackUrl, treasury) {
    this.rpcUrl = rpc;
    this.restUrl = restUrl;
    this.grantContracts = grantContracts;
    this.stake = stake;
    this.bank = bank;
    this.callbackUrl = callbackUrl;
    this.treasury = treasury;
  }
  /**
   * Subscribes to changes in authentication state.
   * When the authentication state changes, the provided callback function is invoked
   * with the new authentication state (isLoggedIn).
   * Returns an unsubscribe function that can be called to remove the subscription.
   *
   * @param {function} callback - A function to be invoked when the authentication state changes.
   *                             Receives a single parameter, isLoggedIn, indicating whether the user is logged in.
   *                             The callback should accept a boolean parameter.
   * @returns {function} - A function that, when called, removes the subscription to authentication state changes.
   *                      This function should be invoked to clean up the subscription when no longer needed.
   */
  subscribeToAuthStateChange(callback) {
    this.authStateChangeSubscribers.push(callback);
    return () => {
      const index = this.authStateChangeSubscribers.indexOf(callback);
      if (index !== -1) {
        this.authStateChangeSubscribers.splice(index, 1);
      }
    };
  }
  /**
   * Triggers a change in authentication state and notifies all subscribers.
   *
   * @param {boolean} isLoggedIn - The new authentication state, indicating whether the user is logged in.
   */
  triggerAuthStateChange(isLoggedIn) {
    this.isLoggedIn = isLoggedIn;
    this.authStateChangeSubscribers.forEach((callback) => callback(isLoggedIn));
  }
  /**
   * Get the account address of the granter from persisted state.
   *
   * @returns {string} The account address of the granter wallet (XION Meta Account).
   */
  async getGranter() {
    const granterAddress = await this.storageStrategy.getItem(
      "xion-authz-granter-account"
    );
    if (!granterAddress || granterAddress === void 0 || granterAddress === "undefined") {
      return "";
    }
    return granterAddress;
  }
  /**
   * Remove persisted instance of granter account.
   */
  async removeGranterAddress() {
    await this.storageStrategy.removeItem("xion-authz-granter-account");
  }
  /**
   * Set a persisted instance for granter account.
   *
   * @param {string} address - account address of the granter wallet (XION Meta Account).
   */
  async setGranter(address) {
    await this.storageStrategy.setItem("xion-authz-granter-account", address);
  }
  /**
   * Get temp keypair from persisted state.
   */
  async getLocalKeypair() {
    const localKeypair = await this.storageStrategy.getItem(
      "xion-authz-temp-account"
    );
    if (!localKeypair) {
      return void 0;
    }
    return await SignArbSecp256k1HdWallet.deserialize(
      localKeypair,
      "abstraxion"
    );
  }
  /**
   * Generate a new temp keypair and store in persisted state.
   */
  async generateAndStoreTempAccount() {
    const keypair = await SignArbSecp256k1HdWallet.generate(12, {
      prefix: "xion"
    });
    const serializedKeypair = await keypair.serialize("abstraxion");
    await this.storageStrategy.setItem(
      "xion-authz-temp-account",
      serializedKeypair
    );
    await this.removeGranterAddress();
    return keypair;
  }
  /**
   * Get keypair account address.
   */
  async getKeypairAddress() {
    const keypair = await this.getLocalKeypair();
    if (!keypair)
      return "";
    const accounts = await keypair.getAccounts();
    const address = accounts[0].address;
    return address;
  }
  /**
   * Get GranteeSignerClient for the temp keypair.
   */
  async getSigner() {
    try {
      if (this.client) {
        return this.client;
      }
      if (!this.rpcUrl) {
        throw new Error("Configuration not initialized");
      }
      if (!this.abstractAccount) {
        throw new Error("No account found.");
      }
      const granterAddress = await this.getGranter();
      if (!granterAddress) {
        throw new Error("No granter found.");
      }
      const granteeAddress = await this.abstractAccount.getAccounts().then((accounts) => {
        if (accounts.length === 0) {
          throw new Error("No account found.");
        }
        return accounts[0].address;
      });
      const directClient = await GranteeSignerClient.connectWithSigner(
        this.rpcUrl,
        this.abstractAccount,
        {
          gasPrice: GasPrice.fromString("0uxion"),
          granterAddress,
          granteeAddress,
          treasuryAddress: this.treasury
        }
      );
      this.client = directClient;
      return directClient;
    } catch (error) {
      console.warn("Something went wrong getting signer: ", error);
      this.client = void 0;
      throw error;
    }
  }
  /**
   * Get non-signing CosmWasmClient
   * @returns {Promise<CosmWasmClient>} A Promise that resolves to a CosmWasmClient
   * @throws {Error} If the rpcUrl is missing, or if there is a network issue.
   */
  async getCosmWasmClient() {
    try {
      if (this.cosmwasmQueryClient) {
        return this.cosmwasmQueryClient;
      }
      if (!this.rpcUrl) {
        throw new Error("Configuration not initialized");
      }
      const cosmwasmClient = await CosmWasmClient.connect(this.rpcUrl || "");
      this.cosmwasmQueryClient = cosmwasmClient;
      return cosmwasmClient;
    } catch (error) {
      console.warn("Something went wrong getting cosmwasm client: ", error);
      this.cosmwasmQueryClient = void 0;
      throw error;
    }
  }
  /**
   * Get dashboard url and redirect in order to issue claim with XION meta account for local keypair.
   */
  async redirectToDashboard() {
    try {
      if (!this.rpcUrl) {
        throw new Error("AbstraxionAuth needs to be configured.");
      }
      const userAddress = await this.getKeypairAddress();
      const { dashboardUrl } = await fetchConfig(this.rpcUrl);
      await this.configureUrlAndRedirect(dashboardUrl, userAddress);
    } catch (error) {
      console.warn(
        "Something went wrong trying to redirect to XION dashboard: ",
        error
      );
    }
  }
  /**
   * Configure URL and redirect page
   */
  async configureUrlAndRedirect(dashboardUrl, userAddress) {
    if (typeof window !== "undefined") {
      const currentUrl = this.callbackUrl || window.location.href;
      const urlParams = new URLSearchParams();
      if (this.treasury) {
        urlParams.set("treasury", this.treasury);
      }
      if (this.bank) {
        urlParams.set("bank", JSON.stringify(this.bank));
      }
      if (this.stake) {
        urlParams.set("stake", "true");
      }
      if (this.grantContracts) {
        urlParams.set("contracts", JSON.stringify(this.grantContracts));
      }
      urlParams.set("grantee", userAddress);
      urlParams.set("redirect_uri", currentUrl);
      const queryString = urlParams.toString();
      await this.redirectStrategy.redirect(`${dashboardUrl}?${queryString}`);
    } else {
      console.warn("Window not defined. Cannot redirect to dashboard");
    }
  }
  /**
   * Compares a GrantsResponse object to the legacy configuration stored in the instance.
   * Validates the presence and attributes of grants for each authorization type.
   *
   * @param {GrantsResponse} grantsResponse - The grants response object containing the chain grants.
   * @returns {boolean} - Returns `true` if the grants match the expected configuration; otherwise, `false`.
   */
  compareGrantsToLegacyConfig(grantsResponse) {
    const { grants } = grantsResponse;
    return compareContractGrants(grants, this.grantContracts) && compareStakeGrants(grants, this.stake) && compareBankGrants(grants, this.bank);
  }
  /**
   * Compares treasury grant configurations with the grants on-chain to ensure they match.
   *
   * @param {GrantsResponse} grantsResponse - The grants currently existing on-chain.
   * @returns {Promise<boolean>} - Returns a promise that resolves to `true` if all treasury grants match chain grants; otherwise, `false`.
   * @throws {Error} - Throws an error if the treasury contract is missing.
   */
  async compareGrantsToTreasury(grantsResponse) {
    if (!this.treasury) {
      throw new Error("Missing treasury");
    }
    const cosmwasmClient = this.cosmwasmQueryClient || await this.getCosmWasmClient();
    const treasuryTypeUrls = await getTreasuryContractTypeUrls(
      cosmwasmClient,
      this.treasury
    );
    const treasuryGrantConfigs = await getTreasuryContractConfigsByTypeUrl(
      cosmwasmClient,
      this.treasury,
      treasuryTypeUrls
    );
    const decodedTreasuryConfigs = treasuryGrantConfigs.map((treasuryGrantConfig) => {
      return decodeAuthorization(
        treasuryGrantConfig.authorization.type_url,
        treasuryGrantConfig.authorization.value
      );
    });
    const decodedChainConfigs = grantsResponse.grants.map((grantResponse) => {
      return decodeAuthorization(
        grantResponse.authorization.typeUrl,
        grantResponse.authorization.value
      );
    });
    return compareChainGrantsToTreasuryGrants(
      decodedChainConfigs,
      decodedTreasuryConfigs
    );
  }
  /**
   * Poll for grants issued to a grantee from a granter.
   *
   * @param {string} grantee - The address of the grantee.
   * @param {string | null} granter - The address of the granter, or null if not available.
   * @returns {Promise<boolean>} A Promise that resolves to true if grants are found, otherwise false.
   * @throws {Error} If the grantee or granter address is invalid, or if maximum retries are exceeded.
   */
  async pollForGrants(grantee, granter) {
    if (!this.rpcUrl) {
      throw new Error("AbstraxionAuth needs to be configured.");
    }
    if (!grantee) {
      throw new Error("No keypair address");
    }
    if (!granter) {
      throw new Error("No granter address");
    }
    const maxRetries = 5;
    let retries = 0;
    while (retries < maxRetries) {
      try {
        const data = await fetchChainGrantsABCI(grantee, granter, this.rpcUrl);
        if (data.grants.length === 0) {
          console.warn("No grants found.");
          return false;
        }
        const currentTime = (/* @__PURE__ */ new Date()).toISOString();
        const validGrant = data.grants.some((grant) => {
          const { expiration } = grant;
          return !expiration || expiration > currentTime;
        });
        let isValid;
        if (this.treasury) {
          isValid = await this.compareGrantsToTreasury(data);
        } else {
          isValid = this.compareGrantsToLegacyConfig(data);
        }
        return validGrant && isValid;
      } catch (error) {
        console.warn("Error fetching grants: ", error);
        const delay = Math.pow(2, retries) * 1e3;
        await new Promise((resolve) => setTimeout(resolve, delay));
        retries++;
      }
    }
    console.error("Max retries exceeded, giving up.");
    return false;
  }
  /**
   * Wipe persisted state and instance variables.
   */
  async logout() {
    await Promise.all([
      this.storageStrategy.removeItem("xion-authz-temp-account"),
      this.storageStrategy.removeItem("xion-authz-granter-account")
    ]);
    this.abstractAccount = void 0;
    this.triggerAuthStateChange(false);
  }
  /**
   * Authenticates the user based on the presence of a local keypair and a granter address.
   * Also checks if the grant is still valid by verifying the expiration.
   * If valid, sets the abstract account and triggers authentication state change.
   * If expired, clears local state and prompts reauthorization.
   *
   * @returns {Promise<void>} - Resolves if authentication is successful or logs out the user otherwise.
   */
  async authenticate() {
    try {
      const keypair = await this.getLocalKeypair();
      const granter = await this.getGranter();
      if (!keypair || !granter) {
        console.warn("Missing keypair or granter, cannot authenticate.");
        return;
      }
      const accounts = await keypair.getAccounts();
      const keypairAddress = accounts[0].address;
      const isGrantValid = await this.pollForGrants(keypairAddress, granter);
      if (isGrantValid) {
        this.abstractAccount = keypair;
        this.triggerAuthStateChange(true);
      } else {
        throw new Error(
          "Grants expired, no longer valid, or not found. Logging out."
        );
      }
    } catch (error) {
      console.error("Error during authentication:", error);
      await this.logout();
    }
  }
  /**
   * Initiates the login process for the user.
   * Checks if a local keypair and granter address exist, either from URL parameters or this.storageStrategy.
   * If both exist, polls for grants and updates the authentication state if successful.
   * If not, generates a new keypair and redirects to the dashboard for grant issuance.
   *
   * @returns {Promise<void>} - A Promise that resolves once the login process is complete.
   * @throws {Error} - If the login process encounters an error.
   */
  async login() {
    try {
      if (this.isLoginInProgress) {
        console.warn("Login is already in progress.");
        return;
      }
      this.isLoginInProgress = true;
      const keypair = await this.getLocalKeypair();
      const storedGranter = await this.getGranter();
      const urlGranter = await this.redirectStrategy.getUrlParameter("granter");
      const granter = storedGranter || urlGranter;
      if (keypair && granter) {
        const accounts = await keypair.getAccounts();
        const keypairAddress = accounts[0].address;
        const pollSuccess = await this.pollForGrants(keypairAddress, granter);
        if (!pollSuccess) {
          throw new Error("Poll was unsuccessful. Please try again");
        }
        this.setGranter(granter);
        this.abstractAccount = keypair;
        this.triggerAuthStateChange(true);
        if (typeof window !== "undefined") {
          const currentUrl = new URL(window.location.href);
          currentUrl.searchParams.delete("granted");
          currentUrl.searchParams.delete("granter");
          history.pushState({}, "", currentUrl.href);
        }
      } else {
        await this.newKeypairFlow();
      }
      return;
    } catch (error) {
      console.warn("Something went wrong: ", error);
      throw error;
    } finally {
      this.isLoginInProgress = false;
    }
  }
  /**
   * Initiates the flow to generate a new keypair and redirect to the dashboard for grant issuance.
   */
  async newKeypairFlow() {
    try {
      await this.generateAndStoreTempAccount();
      await this.redirectToDashboard();
    } catch (error) {
      console.warn("Something went wrong: ", error);
      throw error;
    }
  }
};

export { AbstraxionAuth, AuthorizationTypes, ContractExecFilterTypes, ContractExecLimitTypes, GranteeSignerClient, SignArbSecp256k1HdWallet, compareBankGrants, compareChainGrantsToTreasuryGrants, compareContractGrants, compareStakeGrants, decodeAuthorization, fetchChainGrantsABCI, formatCoinArray, getTreasuryContractConfigsByTypeUrl, getTreasuryContractTypeUrls, isLimitValid, parseCoinString, validateContractExecution };
