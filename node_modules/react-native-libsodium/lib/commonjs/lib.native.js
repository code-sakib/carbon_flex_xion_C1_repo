"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._unstable_crypto_kdf_hkdf_sha256_KEYBYTES = exports._unstable_crypto_kdf_hkdf_sha256_BYTES_MIN = exports._unstable_crypto_kdf_hkdf_sha256_BYTES_MAX = void 0;
exports._unstable_crypto_kdf_hkdf_sha256_expand = _unstable_crypto_kdf_hkdf_sha256_expand;
exports._unstable_crypto_kdf_hkdf_sha256_extract = _unstable_crypto_kdf_hkdf_sha256_extract;
Object.defineProperty(exports, "base64_variants", {
  enumerable: true,
  get: function () {
    return _libsodiumJsUtils.base64_variants;
  }
});
exports.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES = exports.crypto_aead_xchacha20poly1305_ietf_KEYBYTES = void 0;
exports.crypto_aead_xchacha20poly1305_ietf_decrypt = crypto_aead_xchacha20poly1305_ietf_decrypt;
exports.crypto_aead_xchacha20poly1305_ietf_encrypt = crypto_aead_xchacha20poly1305_ietf_encrypt;
exports.crypto_aead_xchacha20poly1305_ietf_keygen = crypto_aead_xchacha20poly1305_ietf_keygen;
exports.crypto_auth = crypto_auth;
exports.crypto_auth_KEYBYTES = exports.crypto_auth_BYTES = void 0;
exports.crypto_auth_keygen = crypto_auth_keygen;
exports.crypto_auth_verify = crypto_auth_verify;
exports.crypto_box_SEEDBYTES = exports.crypto_box_SECRETKEYBYTES = exports.crypto_box_PUBLICKEYBYTES = exports.crypto_box_NONCEBYTES = void 0;
exports.crypto_box_easy = crypto_box_easy;
exports.crypto_box_keypair = crypto_box_keypair;
exports.crypto_box_open_easy = crypto_box_open_easy;
exports.crypto_box_seal = crypto_box_seal;
exports.crypto_box_seal_open = crypto_box_seal_open;
exports.crypto_box_seed_keypair = crypto_box_seed_keypair;
exports.crypto_generichash = crypto_generichash;
exports.crypto_kdf_KEYBYTES = exports.crypto_kdf_CONTEXTBYTES = exports.crypto_generichash_KEYBYTES_MIN = exports.crypto_generichash_KEYBYTES_MAX = exports.crypto_generichash_KEYBYTES = exports.crypto_generichash_BYTES_MIN = exports.crypto_generichash_BYTES_MAX = exports.crypto_generichash_BYTES = void 0;
exports.crypto_kdf_derive_from_key = crypto_kdf_derive_from_key;
exports.crypto_kdf_keygen = crypto_kdf_keygen;
exports.crypto_pwhash = crypto_pwhash;
exports.crypto_secretbox_NONCEBYTES = exports.crypto_secretbox_KEYBYTES = exports.crypto_pwhash_SALTBYTES = exports.crypto_pwhash_OPSLIMIT_INTERACTIVE = exports.crypto_pwhash_MEMLIMIT_INTERACTIVE = exports.crypto_pwhash_BYTES_MIN = exports.crypto_pwhash_BYTES_MAX = exports.crypto_pwhash_ALG_DEFAULT = void 0;
exports.crypto_secretbox_easy = crypto_secretbox_easy;
exports.crypto_secretbox_keygen = crypto_secretbox_keygen;
exports.crypto_secretbox_open_easy = crypto_secretbox_open_easy;
exports.crypto_sign_SEEDBYTES = void 0;
exports.crypto_sign_detached = crypto_sign_detached;
exports.crypto_sign_keypair = crypto_sign_keypair;
exports.crypto_sign_seed_keypair = crypto_sign_seed_keypair;
exports.crypto_sign_verify_detached = crypto_sign_verify_detached;
exports.loadSumoVersion = exports.from_base64 = exports.default = void 0;
exports.randombytes_buf = randombytes_buf;
exports.randombytes_uniform = randombytes_uniform;
exports.to_base64 = exports.ready = void 0;
exports.to_hex = to_hex;
Object.defineProperty(exports, "to_string", {
  enumerable: true,
  get: function () {
    return _libsodiumJsUtils.to_string;
  }
});
var _libsodiumJsUtils = require("./libsodium-js-utils");
var _utils = require("./utils");
var _reactNative = require("react-native");
const Libsodium = _reactNative.NativeModules.Libsodium;
if (Libsodium && typeof Libsodium.install === 'function') {
  console.log('calling Libsodium.install');
  Libsodium.install();
} else if (!Libsodium) {
  console.warn('Libsodium module not defined');
} else {
  console.warn('Libsodium.install not a function');
}
const crypto_auth_BYTES = global.jsi_crypto_auth_BYTES;
exports.crypto_auth_BYTES = crypto_auth_BYTES;
const crypto_auth_KEYBYTES = global.jsi_crypto_auth_KEYBYTES;
exports.crypto_auth_KEYBYTES = crypto_auth_KEYBYTES;
const crypto_secretbox_KEYBYTES = global.jsi_crypto_secretbox_KEYBYTES;
exports.crypto_secretbox_KEYBYTES = crypto_secretbox_KEYBYTES;
const crypto_secretbox_NONCEBYTES = global.jsi_crypto_secretbox_NONCEBYTES;
exports.crypto_secretbox_NONCEBYTES = crypto_secretbox_NONCEBYTES;
const crypto_box_PUBLICKEYBYTES = global.jsi_crypto_box_PUBLICKEYBYTES;
exports.crypto_box_PUBLICKEYBYTES = crypto_box_PUBLICKEYBYTES;
const crypto_box_SECRETKEYBYTES = global.jsi_crypto_box_SECRETKEYBYTES;
exports.crypto_box_SECRETKEYBYTES = crypto_box_SECRETKEYBYTES;
const crypto_box_NONCEBYTES = global.jsi_crypto_box_NONCEBYTES;
exports.crypto_box_NONCEBYTES = crypto_box_NONCEBYTES;
const crypto_box_SEEDBYTES = global.jsi_crypto_box_SEEDBYTES;
exports.crypto_box_SEEDBYTES = crypto_box_SEEDBYTES;
const crypto_aead_xchacha20poly1305_ietf_KEYBYTES = global.jsi_crypto_aead_xchacha20poly1305_ietf_KEYBYTES;
exports.crypto_aead_xchacha20poly1305_ietf_KEYBYTES = crypto_aead_xchacha20poly1305_ietf_KEYBYTES;
const crypto_aead_xchacha20poly1305_ietf_NPUBBYTES = global.jsi_crypto_aead_xchacha20poly1305_ietf_NPUBBYTES;
exports.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES = crypto_aead_xchacha20poly1305_ietf_NPUBBYTES;
const crypto_kdf_KEYBYTES = global.jsi_crypto_kdf_KEYBYTES;
exports.crypto_kdf_KEYBYTES = crypto_kdf_KEYBYTES;
const crypto_kdf_CONTEXTBYTES = global.jsi_crypto_kdf_CONTEXTBYTES;
exports.crypto_kdf_CONTEXTBYTES = crypto_kdf_CONTEXTBYTES;
const crypto_generichash_BYTES = global.jsi_crypto_generichash_BYTES;
exports.crypto_generichash_BYTES = crypto_generichash_BYTES;
const crypto_generichash_BYTES_MIN = global.jsi_crypto_generichash_BYTES_MIN;
exports.crypto_generichash_BYTES_MIN = crypto_generichash_BYTES_MIN;
const crypto_generichash_BYTES_MAX = global.jsi_crypto_generichash_BYTES_MAX;
exports.crypto_generichash_BYTES_MAX = crypto_generichash_BYTES_MAX;
const crypto_generichash_KEYBYTES = global.jsi_crypto_generichash_KEYBYTES;
exports.crypto_generichash_KEYBYTES = crypto_generichash_KEYBYTES;
const crypto_generichash_KEYBYTES_MIN = global.jsi_crypto_generichash_KEYBYTES_MIN;
exports.crypto_generichash_KEYBYTES_MIN = crypto_generichash_KEYBYTES_MIN;
const crypto_generichash_KEYBYTES_MAX = global.jsi_crypto_generichash_KEYBYTES_MAX;
exports.crypto_generichash_KEYBYTES_MAX = crypto_generichash_KEYBYTES_MAX;
const crypto_sign_SEEDBYTES = global.jsi_crypto_sign_SEEDBYTES;
exports.crypto_sign_SEEDBYTES = crypto_sign_SEEDBYTES;
const crypto_pwhash_SALTBYTES = global.jsi_crypto_pwhash_SALTBYTES;
exports.crypto_pwhash_SALTBYTES = crypto_pwhash_SALTBYTES;
const crypto_pwhash_ALG_DEFAULT = global.jsi_crypto_pwhash_ALG_DEFAULT;
exports.crypto_pwhash_ALG_DEFAULT = crypto_pwhash_ALG_DEFAULT;
const crypto_pwhash_OPSLIMIT_INTERACTIVE = global.jsi_crypto_pwhash_OPSLIMIT_INTERACTIVE;
exports.crypto_pwhash_OPSLIMIT_INTERACTIVE = crypto_pwhash_OPSLIMIT_INTERACTIVE;
const crypto_pwhash_MEMLIMIT_INTERACTIVE = global.jsi_crypto_pwhash_MEMLIMIT_INTERACTIVE;
exports.crypto_pwhash_MEMLIMIT_INTERACTIVE = crypto_pwhash_MEMLIMIT_INTERACTIVE;
const crypto_pwhash_BYTES_MIN = global.jsi_crypto_pwhash_BYTES_MIN;
exports.crypto_pwhash_BYTES_MIN = crypto_pwhash_BYTES_MIN;
const crypto_pwhash_BYTES_MAX = global.jsi_crypto_pwhash_BYTES_MAX;
exports.crypto_pwhash_BYTES_MAX = crypto_pwhash_BYTES_MAX;
const _unstable_crypto_kdf_hkdf_sha256_BYTES_MAX = global.jsi_crypto_kdf_hkdf_sha256_BYTES_MAX;
exports._unstable_crypto_kdf_hkdf_sha256_BYTES_MAX = _unstable_crypto_kdf_hkdf_sha256_BYTES_MAX;
const _unstable_crypto_kdf_hkdf_sha256_BYTES_MIN = global.jsi_crypto_kdf_hkdf_sha256_BYTES_MIN;
exports._unstable_crypto_kdf_hkdf_sha256_BYTES_MIN = _unstable_crypto_kdf_hkdf_sha256_BYTES_MIN;
const _unstable_crypto_kdf_hkdf_sha256_KEYBYTES = global.jsi_crypto_kdf_hkdf_sha256_KEYBYTES;
exports._unstable_crypto_kdf_hkdf_sha256_KEYBYTES = _unstable_crypto_kdf_hkdf_sha256_KEYBYTES;
const from_base64 = (input, variant) => {
  const variantToUse = variant || _libsodiumJsUtils.base64_variants.URLSAFE_NO_PADDING;
  const result = global.jsi_from_base64_to_arraybuffer(input, variantToUse);
  return new Uint8Array(result);
};
exports.from_base64 = from_base64;
const to_base64 = (input, variant) => {
  const variantToUse = variant || _libsodiumJsUtils.base64_variants.URLSAFE_NO_PADDING;
  const inputParam = typeof input === 'string' ? input : input.buffer;
  return global.jsi_to_base64(inputParam, variantToUse);
};
exports.to_base64 = to_base64;
function to_hex(input) {
  const inputParam = typeof input === 'string' ? input : input.buffer;
  return global.jsi_to_hex(inputParam);
}
function randombytes_buf(length, outputFormat) {
  const result = global.jsi_randombytes_buf(length);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function randombytes_uniform(upper_bound) {
  return global.jsi_randombytes_uniform(upper_bound);
}
function crypto_auth(message, key, outputFormat) {
  const messageParam = typeof message === 'string' ? message : message.buffer;
  const result = global.jsi_crypto_auth(messageParam, key.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_auth_keygen(outputFormat) {
  const result = global.jsi_crypto_auth_keygen();
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_auth_verify(tag, message, key) {
  const messageParam = typeof message === 'string' ? message : message.buffer;
  return global.jsi_crypto_auth_verify(tag.buffer, messageParam, key.buffer);
}
function crypto_secretbox_keygen(outputFormat) {
  const result = global.jsi_crypto_secretbox_keygen();
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_aead_xchacha20poly1305_ietf_keygen(outputFormat) {
  const result = global.jsi_crypto_aead_xchacha20poly1305_ietf_keygen();
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_kdf_keygen(outputFormat) {
  const result = global.jsi_crypto_kdf_keygen();
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_box_keypair(outputFormat) {
  const result = global.jsi_crypto_box_keypair();
  return {
    keyType: 'x25519',
    publicKey: (0, _utils.convertToOutputFormat)(result.publicKey, outputFormat),
    privateKey: (0, _utils.convertToOutputFormat)(result.secretKey, outputFormat)
  };
}
function crypto_box_seed_keypair(seed, outputFormat) {
  const result = global.jsi_crypto_box_seed_keypair(seed.buffer);
  return {
    keyType: 'x25519',
    publicKey: (0, _utils.convertToOutputFormat)(result.publicKey, outputFormat),
    privateKey: (0, _utils.convertToOutputFormat)(result.secretKey, outputFormat)
  };
}
function crypto_sign_keypair(outputFormat) {
  const result = global.jsi_crypto_sign_keypair();
  return {
    keyType: 'ed25519',
    publicKey: (0, _utils.convertToOutputFormat)(result.publicKey, outputFormat),
    privateKey: (0, _utils.convertToOutputFormat)(result.secretKey, outputFormat)
  };
}
function crypto_sign_seed_keypair(seed, outputFormat) {
  const result = global.jsi_crypto_sign_seed_keypair(seed.buffer);
  return {
    keyType: 'ed25519',
    publicKey: (0, _utils.convertToOutputFormat)(result.publicKey, outputFormat),
    privateKey: (0, _utils.convertToOutputFormat)(result.secretKey, outputFormat)
  };
}
function crypto_sign_detached(message, privateKey, outputFormat) {
  let result;
  const messageParam = typeof message === 'string' ? message : message.buffer;
  result = global.jsi_crypto_sign_detached(messageParam, privateKey.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_sign_verify_detached(signature, message, publicKey) {
  let result;
  const messageParam = typeof message === 'string' ? message : message.buffer;
  result = global.jsi_crypto_sign_verify_detached(signature.buffer, messageParam, publicKey.buffer);
  return result;
}
function crypto_secretbox_easy(message, nonce, key, outputFormat) {
  let result;
  const messageParam = typeof message === 'string' ? message : message.buffer;
  result = global.jsi_crypto_secretbox_easy(messageParam, nonce.buffer, key.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_secretbox_open_easy(ciphertext, nonce, key, outputFormat) {
  let result;
  const ciphertextParam = typeof ciphertext === 'string' ? ciphertext : ciphertext.buffer;
  result = global.jsi_crypto_secretbox_open_easy(ciphertextParam, nonce.buffer, key.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_box_easy(message, nonce, publicKey, privateKey, outputFormat) {
  let result;
  const messageParam = typeof message === 'string' ? message : message.buffer;
  result = global.jsi_crypto_box_easy(messageParam, nonce.buffer, publicKey.buffer, privateKey.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_box_open_easy(ciphertext, nonce, publicKey, privateKey, outputFormat) {
  let result;
  const ciphertextParam = typeof ciphertext === 'string' ? ciphertext : ciphertext.buffer;
  result = global.jsi_crypto_box_open_easy(ciphertextParam, nonce.buffer, publicKey.buffer, privateKey.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_box_seal(ciphertext, publicKey, outputFormat) {
  let result;
  const ciphertextParam = typeof ciphertext === 'string' ? ciphertext : ciphertext.buffer;
  result = global.jsi_crypto_box_seal(ciphertextParam, publicKey.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_box_seal_open(ciphertext, publicKey, privateKey, outputFormat) {
  let result;
  const ciphertextParam = typeof ciphertext === 'string' ? ciphertext : ciphertext.buffer;
  result = global.jsi_crypto_box_seal_open(ciphertextParam, publicKey.buffer, privateKey.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_generichash(hash_length, message, key, outputFormat) {
  const messageParam = typeof message === 'string' ? message : message.buffer;
  const result = global.jsi_crypto_generichash(hash_length, messageParam, key ? key.buffer : undefined);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_pwhash(keyLength, password, salt, opsLimit, memLimit, algorithm, outputFormat) {
  if (salt.length !== crypto_pwhash_SALTBYTES) {
    throw new Error('invalid salt length');
  }
  let result;
  const passwordParam = typeof password === 'string' ? password : password.buffer;
  result = global.jsi_crypto_pwhash(keyLength, passwordParam, salt.buffer, opsLimit, memLimit, algorithm);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_kdf_derive_from_key(subkey_len, subkey_id, ctx, key, outputFormat) {
  const result = global.jsi_crypto_kdf_derive_from_key(subkey_len, subkey_id, ctx, key.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_aead_xchacha20poly1305_ietf_encrypt(message, additional_data, _secret_nonce, public_nonce, key, outputFormat) {
  let result;
  const messageParam = typeof message === 'string' ? message : message.buffer;
  if (typeof additional_data !== 'string') {
    throw new Error('crypto_aead_xchacha20poly1305_ietf_encrypt: input type not yet implemented');
  }
  result = global.jsi_crypto_aead_xchacha20poly1305_ietf_encrypt(messageParam, additional_data, public_nonce.buffer, key.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function crypto_aead_xchacha20poly1305_ietf_decrypt(_secret_nonce, ciphertext, additional_data, public_nonce, key, outputFormat) {
  let result;
  if (typeof ciphertext === 'string') {
    throw new Error('crypto_aead_xchacha20poly1305_ietf_decrypt: input type not yet implemented');
  }
  if (typeof additional_data !== 'string') {
    throw new Error('crypto_aead_xchacha20poly1305_ietf_decrypt: input type not yet implemented');
  }
  const ciphertextParam = typeof ciphertext === 'string' ? ciphertext : ciphertext.buffer;
  result = global.jsi_crypto_aead_xchacha20poly1305_ietf_decrypt(ciphertextParam, additional_data, public_nonce.buffer, key.buffer);
  return (0, _utils.convertToOutputFormat)(result, outputFormat);
}
function _unstable_crypto_kdf_hkdf_sha256_extract(key, salt) {
  return new Uint8Array(global.jsi_crypto_kdf_hkdf_sha256_extract(key.buffer, salt.buffer));
}
function _unstable_crypto_kdf_hkdf_sha256_expand(key, info, length) {
  return new Uint8Array(global.jsi_crypto_kdf_hkdf_sha256_expand(key.buffer, info, length));
}

// add no-op ready to match the libsodium-wrappers API
const ready = new Promise(resolve => resolve());

// add no-op ready to match the react-nativ-libsodium API for web
exports.ready = ready;
const loadSumoVersion = () => undefined;
exports.loadSumoVersion = loadSumoVersion;
var _default = {
  crypto_auth,
  crypto_auth_verify,
  crypto_auth_BYTES,
  crypto_auth_KEYBYTES,
  crypto_auth_keygen,
  crypto_aead_xchacha20poly1305_ietf_decrypt,
  crypto_aead_xchacha20poly1305_ietf_encrypt,
  crypto_aead_xchacha20poly1305_ietf_KEYBYTES,
  crypto_aead_xchacha20poly1305_ietf_keygen,
  crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,
  crypto_box_easy,
  crypto_box_seed_keypair,
  crypto_box_keypair,
  crypto_box_NONCEBYTES,
  crypto_box_open_easy,
  crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES,
  crypto_generichash,
  crypto_generichash_BYTES,
  crypto_generichash_BYTES_MIN,
  crypto_generichash_BYTES_MAX,
  crypto_generichash_KEYBYTES,
  crypto_generichash_KEYBYTES_MIN,
  crypto_generichash_KEYBYTES_MAX,
  crypto_kdf_derive_from_key,
  crypto_kdf_CONTEXTBYTES,
  crypto_kdf_KEYBYTES,
  crypto_kdf_keygen,
  crypto_pwhash,
  crypto_pwhash_ALG_DEFAULT,
  crypto_pwhash_BYTES_MAX,
  crypto_pwhash_BYTES_MIN,
  crypto_pwhash_MEMLIMIT_INTERACTIVE,
  crypto_pwhash_OPSLIMIT_INTERACTIVE,
  crypto_pwhash_SALTBYTES,
  crypto_secretbox_easy,
  crypto_secretbox_KEYBYTES,
  crypto_secretbox_keygen,
  crypto_secretbox_NONCEBYTES,
  crypto_secretbox_open_easy,
  crypto_sign_detached,
  crypto_sign_keypair,
  crypto_sign_verify_detached,
  from_base64,
  randombytes_buf,
  randombytes_uniform,
  ready,
  to_base64,
  to_hex,
  to_string: _libsodiumJsUtils.to_string,
  _unstable_crypto_kdf_hkdf_sha256_BYTES_MAX,
  _unstable_crypto_kdf_hkdf_sha256_BYTES_MIN,
  _unstable_crypto_kdf_hkdf_sha256_KEYBYTES,
  _unstable_crypto_kdf_hkdf_sha256_extract,
  _unstable_crypto_kdf_hkdf_sha256_expand
};
exports.default = _default;
//# sourceMappingURL=lib.native.js.map